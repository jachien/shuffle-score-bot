options {
    STATIC = false;
    IGNORE_CASE = true;
    LOOKAHEAD = 2;
    FORCE_LA_CHECK = true;
}

PARSER_BEGIN(RunParser)
package org.jchien.shuffle.parser;

import java.util.ArrayList;
import java.util.List;

public class RunParser {
    private List<RawPokemon> team = new ArrayList<RawPokemon>();
    private boolean teamSet = false;

    private List<String> items = new ArrayList<String>();
    private boolean itemsSet = false;

    private String score = null;

    private String stage = null;

    private String movesLeft = null;

    private RawPokemonBuilder pkmnBuilder = null;

    public RunParser() {
    }

    public RawRunDetails getDetails() {
        return new RawRunDetails(team, items, score, stage, movesLeft);
    }

    public static void main(String[] args) throws ParseException, TokenMgrError, DupeSectionException {
        RunParser parser = new RunParser(System.in);
        parser.start();
        System.out.println(parser.getDetails());
    }

    private String value(Token t) {
        if (t == null) {
            return null;
        }
        return t.image;
    }

    private void initPokemon() {
        pkmnBuilder = new RawPokemonBuilder();
    }

    private void storePokemon() {
        team.add(pkmnBuilder.build());
    }
}
PARSER_END(RunParser)

SKIP: {
    " "
    | "\t"
    | "\n"
    | "\r"
}

TOKEN: {
    < PERFECT: "PERFECT" >
}

TOKEN: {
    < #DIGIT: (["0"-"9"]) >
    | < #LETTER: (["A"-"Z"]) >
    | < WORD: <LETTER> (<DIGIT> | <LETTER> | "+" | "-" | "?" | "!")* >
    | < NUM: (<DIGIT>)+ >
    | < SLASH: "/" >
}

TOKEN: {
    < RUN_HEADER: "!RUN" >
    | < EB_HEADER: "!EB" >
    | < TEAM_HEADER: "TEAM:" >
    | < SCORE_HEADER: "SCORE:" >
    | < ITEMS_HEADER: "ITEMS:" >
    | < MOVES_LEFT_HEADER: "MOVES LEFT:" >
    | < END_HEADER: "!END" >
}

// goal is to have simplest grammar, validate after parsing

// top level production
void start() throws DupeSectionException: {} {
    run() <EOF>
}

void run() throws DupeSectionException: {
    Token t;
} {
    (<RUN_HEADER> | (<EB_HEADER> t=<NUM> { stage = t.image; }))
    (section())+
    <END_HEADER>
}

void section() throws DupeSectionException: {} {
    team() | score() | items() | movesLeft()
}

void team() throws DupeSectionException: {
} {
    {
        if (teamSet) {
            throw new DupeSectionException(Section.TEAM);
        }
        teamSet = true;
        initPokemon();
    }
    <TEAM_HEADER> support() ({ storePokemon(); initPokemon(); } "," support())*
    { storePokemon(); }
}

// <pokemon> ( <perfect> | "(" (<level>, <skill level> <skill name>, <msu_count>/<max_msus> ")"
void support(): {
    Token t = null;
    StringBuilder sb = new StringBuilder();
} {
    t=<WORD>
    { sb.append(t.image); }
    (t=<WORD> { sb.append(' ').append(t.image); })*
    { pkmnBuilder.setName(sb.toString()); }
    "(" (<PERFECT> { pkmnBuilder.setPerfect(true); } | (supportSection() ("," supportSection())*)) ")"
}

void supportSection(): {
} {
    // todo dupe section exceptions
    // order seems to matter here due to potential ambiguity even with lookahead
    msus() | skill() | level()
}

void level(): {
    Token t;
} {
    t=<NUM> { pkmnBuilder.setLevel(t.image); }
}

void skill(): {
    Token t;
    StringBuilder sb = new StringBuilder();
} {
    ( t=<WORD> | t=<NUM>) { sb.append(t.image); }
    ( t=<WORD> | t=<NUM> { sb.append(' ').append(t.image); } )*
    { pkmnBuilder.setSkill(sb.toString()); }
}

void msus(): {
    Token tMsuCount;
    Token tMaxMsus;
} {
    tMsuCount=<NUM> <SLASH> tMaxMsus=<NUM>
    { pkmnBuilder.setMsus(tMsuCount.image + "/" + tMaxMsus.image); }
}

void score() throws DupeSectionException: {
    Token t;
    StringBuilder sb = new StringBuilder();
} {
    {
        if (score != null) {
            throw new DupeSectionException(Section.SCORE);
        }
    }
    <SCORE_HEADER> t=<NUM>
    { sb.append(t.image); }
    ( ("," | ".") t=<NUM> { sb.append(t.image); } )*
    { score = sb.toString(); }
}

void items() throws DupeSectionException: {
    Token t;
} {
    {
        if (itemsSet) {
            throw new DupeSectionException(Section.ITEMS);
        }
        itemsSet = true;
    }
    <ITEMS_HEADER> t=<WORD> { items.add(t.image); } ("," t=<WORD> { items.add(t.image); })*
}

void movesLeft() throws DupeSectionException: {
    Token t;
} {
    {
        if (movesLeft != null) {
            throw new DupeSectionException(Section.MOVES);
        }
    }
    <MOVES_LEFT_HEADER> t=<NUM>
    { movesLeft = t.image; }
}
